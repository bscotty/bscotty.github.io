<script src=M.js></script>
<script src=lib2k.js></script>
<script src=SHAPE.js></script>

<body bgcolor=black text=white style="text-align: center">
<canvas id='canvas1' width=600 height=600 style="border: white solid 2px"></canvas>
</body>

<script id="vs_script" type="x-shader/x-vertex">

   attribute vec3 aPos, aNor;
   attribute vec2 aUV;
   varying   vec3 vPos, vNor;
   varying   vec2 vUV;
   uniform   mat4 matrix, invMatrix;
   void main() {
      vec4 pos = matrix * vec4(aPos, 1.);
      vec4 nor = vec4(aNor, 0.) * invMatrix;
      gl_Position = pos;
      vPos = pos.xyz;
      vNor = nor.xyz;
      vUV  = aUV;
   }
</script>

<script id="fs_script" type="x-shader/x-fragment">

varying vec3 vPos, vNor;
void main() {
   vec3 normal = normalize(vNor);
   vec3 c = normal * .5 + .5;

   /* Begin Phong Shading. */
   vec3 L = normalize(vec3(.8,.8,.2));     // Light
   vec3 Lcol = vec3(.8, .5, .8);        // Light Color
   vec3 R = 2. * normal * dot(normal, L) - L;   // R

   vec3 a = vec3(.2, 0,.2); // ambient
   vec3 d = vec3(.5,.4,.5); // diffuse
   vec3 s = vec3(.3,.2,.3); // specular
   vec3 E = normalize(-L);  // direction back

   c = a + Lcol *
       (d * max(0., dot(normal, L)) +
        s * pow(max(0., dot(E, R)), 2.5));
   /* End Phong Shading. */
   gl_FragColor = vec4(sqrt(c), 1.);
}
</script>

<script id="fs_script_2" type="x-shader/x-fragment">
varying vec3 vPos, vNor;
varying vec2 vUV;
uniform sampler2D uSampler;
void main() {
   vec3 normal = normalize(vNor);
   vec3 c = normal * .5 + .5;

   /* Begin Phong Shading. */
   vec3 L = normalize(vec3(.8,.8,.2));     // Light
   vec3 Lcol = vec3(.8, .5, .8);        // Light Color
   vec3 R = 2. * normal * dot(normal, L) - L;   // R

   vec3 a = vec3(.2, 0,.2); // ambient
   vec3 d = vec3(.5,.4,.5); // diffuse
   vec3 s = vec3(.3,.2,.3); // specular
   vec3 E = normalize(-L);  // direction back

   c = a + Lcol *
       (d * max(0., dot(normal, L)) +
        s * pow(max(0., dot(E, R)), 2.5));
   /* End Phong Shading. */
   vec4 texture = texture2D(uSampler, vUV);
   c += 0.2 * texture.rgb;
   gl_FragColor = vec4(sqrt(c), 1.);
}
</script>

<script>
    function calculateNormal(point1, point2, point3) {
        const normal = [];

        const U = [point2[0] - point1[0], point2[1] - point1[1], point2[2] - point1[2]];
        const V = [point3[0] - point1[0], point3[1] - point1[1], point3[2] - point1[2]];

        normal[0] = (U[1] * V[2]) - (U[2] * V[1]); // Nx = (Uy * Vz) − (Uz * Vy);
        normal[1] = (U[2] * V[0]) - (U[0] * V[2]); // Ny = (Uz * Vx) − (Ux * Vz)
        normal[2] = (U[0] * V[1]) - (U[1] * V[0]); // Nz = (Ux * Vy) − (Uy * Vx)

        return normal;
    }

    function addToScene(obj, material, vertices, scene) {
        const v = [];
        for (let i = 0; i < vertices.length; i++) {
            const polygon = vertices[i];
            for (let j = 0; j < (polygon.length - 2); j++) {
                const normal = calculateNormal(polygon[j], polygon[j + 1], polygon[j + 2]);
                v.push(...polygon[0], ...normal, 1, -1);
                v.push(...polygon[j + 1], ...normal, 1, 1);
                v.push(...polygon[j + 2], ...normal, -1, 1);
            }
        }
        obj.setMaterial(material);
        obj.setVertices(v);
        scene.addObject(obj);
    }

    window.addEventListener('load', function () {
        const mIcosahedron = M.identityMatrix();
        const mDodecahedron = M.identityMatrix();
        const mOctahedron = M.identityMatrix();
        const mCube = M.identityMatrix();
        const mTetrahedron = M.identityMatrix();

        const canvas1 = document.querySelector('#canvas1');
        const vs = document.querySelector('#vs_script').innerHTML;
        const fs = document.querySelector('#fs_script').innerHTML;
        const fs2 = document.querySelector('#fs_script_2').innerHTML;
        const scene = new Scene();

        let obj1 = new SceneObject();
        const material1 = new Material(vs, fs);
        let vertices = SHAPE.unitIcosahedron();
        addToScene(obj1, material1, vertices, scene);

        let obj2 = new SceneObject();
        const material2 = new Material(vs, fs);
        vertices = SHAPE.unitDodecahedron();
        addToScene(obj2, material2, vertices, scene);

        let obj3 = new SceneObject();
        const material3 = new Material(vs, fs);
        vertices = SHAPE.unitOctahedron();
        addToScene(obj3, material3, vertices, scene);

        let obj4 = new SceneObject();
        const material4 = new Material(vs, fs);
        vertices = SHAPE.unitCube();
        addToScene(obj4, material4, vertices, scene);

        let obj5 = new SceneObject();
        const material5 = new Material(vs, fs);
        vertices = SHAPE.unitTetrahedron();
        addToScene(obj5, material5, vertices, scene);

        canvas1.scene = scene;

        gl_start(canvas1, function (time) {
            //time = 15;
            // Animate Icosahedron
            M.identity(mIcosahedron);
            M.translate(mIcosahedron, [-.5, .5, 0]);
            M.rotateY(mIcosahedron, time);
            //M.rotateZ(mIcosahedron, time);
            M.scale(mIcosahedron, 0.2);

            M.save(mIcosahedron);
            obj1.setMatrix(mIcosahedron);
            M.restore(mIcosahedron);

            // Animate Dodecahedron
            M.identity(mDodecahedron);
            M.translate(mDodecahedron, [.5, .5, 0]);
            M.rotateY(mDodecahedron, time);
            //M.rotateZ(mDodecahedron, time);
            M.scale(mDodecahedron, 0.2);

            M.save(mDodecahedron);
            obj2.setMatrix(mDodecahedron);
            M.restore(mDodecahedron);

            // Animate Octahedron
            M.identity(mOctahedron);
            M.translate(mOctahedron, [-.5, -.5, 0]);
            M.rotateY(mOctahedron, time);
            //M.rotateZ(mOctahedron, time);
            M.scale(mOctahedron, 0.4);

            M.save(mOctahedron);
            obj3.setMatrix(mOctahedron);
            M.restore(mOctahedron);

            // Animate Cube
            M.identity(mCube);
            M.translate(mCube, [0, 0, .3]);
            M.rotateY(mCube, time);
            //M.rotateZ(mCube, time);
            M.scale(mCube, 0.2);

            M.save(mCube);
            obj4.setMatrix(mCube);
            M.restore(mCube);

            // Animate Tetrahedron
            M.identity(mTetrahedron);
            M.translate(mTetrahedron, [.5, -.5, 0]);
            M.rotateY(mTetrahedron, time);
            //M.rotateZ(mTetrahedron, time);
            M.scale(mTetrahedron, 0.35);

            M.save(mTetrahedron);
            obj5.setMatrix(mTetrahedron);
            M.restore(mTetrahedron);
        });
    });
</script>

