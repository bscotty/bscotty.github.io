<script src=lib5.js></script>
<script src=noise_shader.js></script>

<body bgcolor=black text=white>
    <center>
        <canvas id='canvas1' width=600 height=600></canvas>
    </center>
</body>

<script id='vs_script' type='x-shader/x-vertex'>
   attribute vec3 aPos;
   varying   vec3 vPos;
   void main() {
      gl_Position = vec4(aPos, 1.0);
      vPos = aPos;
   }
</script>

<script id='fss_script' type='x-shader/x-fragment'>

---------------------------------------------------------------------
varying vec3 vPos;                         // Position in image
uniform float uTime;                       // Time

struct Light {                             // Light source data.
   vec3 direction;
   vec3 color;
};

struct Material {                          // Surface material data.
   vec3  ambient;
   vec3  diffuse;
   vec3  specular;
   float power;
};

struct Sphere {                            // Sphere object data.
   vec3     center;
   float    radius;
   Material material;
};

uniform Light uLights[NLIGHTS];            // All the lights.
uniform Sphere uSpheres[NSPHERES];         // All the spheres.

vec2 raytraceSphere(vec3 V, vec3 W, Sphere S) {
   V -= S.center;
   float B = 2. * dot(V, W);
   float C = dot(V, V) - S.radius * S.radius;
   float discrim = B*B - 4.*C;
   vec2 t = vec2(1000., 1000.);
   if (discrim > 0.)
      t = vec2(-B - discrim, -B + discrim) / 2.;
   return t.x > 0. ? t : vec2(1000., 1000.);
}

vec3 backgroundColor(vec3 dir) {
   float t = .5 - .5 * dir.y;
   return mix(vec3(.2,.01,.01), vec3(.01,.01,.1), 1. - t * t);
}

vec3 phong(vec3 P, vec3 N, vec3 E, Material C) {
   vec3 c = C.ambient * backgroundColor(N);       // Ambient color
   for (int i = 0 ; i < NLIGHTS ; i++) { // Loop through lights
      vec3 L = normalize(uLights[i].direction);
      vec2 t;
      for (int j = 0 ; j < NSPHERES ; j++) {// Loop through spheres.
         t = raytraceSphere(P+.001*L, L, uSpheres[j]);
         if (t.x < 1000.)// If any casts a shadow then stop looping.
            break;
      }
      if (t.x == 1000.) {                      // If not in shadow:
         float d = max(0., dot(N, L));                // Diffuse
         vec3  R = reflect(-L, N);
         float s = pow(max(0., dot(E, R)), C.power);  // Specular
         c += uLights[i].color
              * (d * C.diffuse + s * C.specular * .1*C.power);
      }
   }
   return c;
}

Material C;
vec3 V, W, P, E, N;

bool raytrace() {
   float distance = 1000.;
   for (int i = 0 ; i < NSPHERES ; i++) {
      vec2 t = raytraceSphere(V, W, uSpheres[i]);
      if (t.x < distance) {                    // Properties for Obj
         C = uSpheres[i].material;             // Material
         P = V + t.x * W;                      // Point on sphere
         E = -normalize(P);                    // Direction to eye
         N = normalize(P - uSpheres[i].center);// Surface normal
         distance = t.x;
      }
   }
   return distance < 1000.;
}

void main() {
   vec3 c = vec3(0.,0.,0.);

   V = vec3(0.,0.,0.);                         // Ray origin
   W = normalize(vec3(vPos.xy, -3.));          // Ray direction
   if (! raytrace())
      c = backgroundColor(vPos);
   else
      for (int bounce = 0 ; bounce < 5 ; bounce++) {
         float attenuation = pow(0.6, float(bounce + 1));
         c += attenuation * phong(P, N, E, C);
         c += .5 * attenuation * backgroundColor(W);
         V = P + .001 * W;
         W = reflect(W, N);
         if (! raytrace())
            break;
      }

   gl_FragColor = vec4(sqrt(c), 1.);           // Final pixel color
}
---------------------------------------------------------------------
Professor Perlin's Code, a jumping off point.
---------------------------------------------------------------------
                                     xx
---------------------------------------------------------------------
varying vec3 vPos;                         // Position in image
uniform float uTime;                       // Time

struct Light {                             // Light source data.
   vec3 direction;
   vec3 color;
};

struct Material {                          // Surface material data.
   vec3  ambient;
   vec3  diffuse;
   vec3  specular;
   float power;
};

struct Sphere {                            // Sphere object data.
   vec3     center;
   float    radius;
   Material material;
};

uniform Light uLights[NLIGHTS];            // All the lights.
uniform Sphere uSpheres[NSPHERES];         // All the spheres.

vec2 raytraceSphere(vec3 V, vec3 W, Sphere S) {
   V -= S.center;
   float B = 2. * dot(V, W);
   float C = dot(V, V) - S.radius * S.radius;
   float discrim = B*B - 4.*C;
   vec2 t = vec2(1000., 1000.);
   if (discrim > 0.)
      t = vec2(-B - discrim, -B + discrim) / 2.;
   return t.x > 0. ? t : vec2(1000., 1000.);
}

vec3 backgroundColor(vec3 dir) {
   float t = .5 - .5 * dir.y;
   return mix(vec3(.2,.01,.01), vec3(.01,.01,.1), 1. - t * t) *
               (turbulence(vec3(t, t, t)) * 5.);
}

vec3 phong(vec3 P, vec3 N, vec3 E, Material C) {
   vec3 c = C.ambient * backgroundColor(N);       // Ambient color
   for (int i = 0 ; i < NLIGHTS ; i++) { // Loop through lights
      vec3 L = normalize(uLights[i].direction);
      vec2 t;
      for (int j = 0 ; j < NSPHERES ; j++) {// Loop through spheres.
         t = raytraceSphere(P+.001*L, L, uSpheres[j]);
         if (t.x < 1000.)// If any casts a shadow then stop looping.
            break;
      }
      if (t.x == 1000.) {                      // If not in shadow:
         float d = max(0., dot(N, L));                // Diffuse
         vec3  R = reflect(-L, N);
         float s = pow(max(0., dot(E, R)), C.power);  // Specular
         c += uLights[i].color
              * (d * C.diffuse + s * C.specular * .1*C.power);
      }
   }
   return c;
}

Material C;
vec3 V, W, P, E, N;

bool raytrace() {
   float distance = 1000.;
   for (int i = 0 ; i < NSPHERES ; i++) {
      vec2 t = raytraceSphere(V, W, uSpheres[i]);
      if (t.x < distance) {                    // Properties for Obj
         C = uSpheres[i].material;             // Material
         P = V + t.x * W;                      // Point on sphere
         E = -normalize(P);                    // Direction to eye
         N = normalize(P - uSpheres[i].center);// Surface normal
         distance = t.x;
      }
   }
   return distance < 1000.;
}

void main() {
   vec3 c = vec3(0.,0.,0.);

   V = vec3(0.,0.,0.);                         // Ray origin
   W = normalize(vec3(vPos.xy, -3.));          // Ray direction
   if (! raytrace())
      c = backgroundColor(vPos);
   else
      for (int bounce = 0 ; bounce < 5 ; bounce++) {
         float attenuation = pow(0.6, float(bounce + 1));
         c += attenuation * phong(P, N, E, C);
         c += .5 * attenuation * backgroundColor(W);
         V = P + .001 * W;
         W = reflect(W, N);
         if (! raytrace())
            break;
      }

   gl_FragColor = vec4(sqrt(c), 1.);           // Final pixel color
}
---------------------------------------------------------------------
Adding turbulence to the background function gives us a cool texture.
---------------------------------------------------------------------
                                                           xxx
---------------------------------------------------------------------
varying vec3 vPos;                         // Position in image
uniform float uTime;                       // Time

struct Light {                             // Light source data.
   vec3 direction;
   vec3 color;
};

struct Material {                          // Surface material data.
   vec3  ambient;
   vec3  diffuse;
   vec3  specular;
   float power;
};

struct Sphere {                            // Sphere object data.
   vec3     center;
   float    radius;
   Material material;
};

uniform Light uLights[NLIGHTS];            // All the lights.
uniform Sphere uSpheres[NSPHERES];         // All the spheres.

vec2 raytraceSphere(vec3 V, vec3 W, Sphere S) {
   V -= S.center;
   float B = 2. * dot(V, W);
   float C = dot(V, V) - S.radius * S.radius;
   float discrim = B*B - 4.*C;
   vec2 t = vec2(1000., 1000.);
   if (discrim > 0.)
      t = vec2(-B - discrim, -B + discrim) / 2.;
   return t.x > 0. ? t : vec2(1000., 1000.);
}

vec3 backgroundColor(vec3 dir) {
   float t = .5 - .5 * dir.y;
   return mix(vec3(.2,.01,.01), vec3(.01,.01,.1), 1. - t * t) *
               (turbulence(vec3(t, t, t)) * 5.);
}

vec3 phong(vec3 P, vec3 N, vec3 E, Material C) {
   vec3 c = C.ambient * backgroundColor(N);       // Ambient color
   for (int i = 0 ; i < NLIGHTS ; i++) { // Loop through lights
      vec3 L = normalize(uLights[i].direction);
      vec2 t;
      for (int j = 0 ; j < NSPHERES ; j++) {// Loop through spheres.
         t = raytraceSphere(P+.001*L, L, uSpheres[j]);
         if (t.x < 1000.)// If any casts a shadow then stop looping.
            break;
      }
      if (t.x == 1000.) {                      // If not in shadow:
         float d = max(0., dot(N, L));                // Diffuse
         vec3  R = reflect(-L, N);
         float s = pow(max(0., dot(E, R)), C.power);  // Specular
         c += uLights[i].color
              * (d * C.diffuse + s * C.specular * .1*C.power);
      }
   }
   return c + vec3(.16, .5, .16) *
          sin(noise(15. * c + vec3(10.,10.,10.)) *
          turbulence(c + vec3(0., 0., .11)));
}

Material C;
vec3 V, W, P, E, N;

bool raytrace() {
   float distance = 1000.;
   for (int i = 0 ; i < NSPHERES ; i++) {
      vec2 t = raytraceSphere(V, W, uSpheres[i]);
      if (t.x < distance) {                    // Properties for Obj
         C = uSpheres[i].material;             // Material
         P = V + t.x * W;                      // Point on sphere
         E = -normalize(P);                    // Direction to eye
         N = normalize(P - uSpheres[i].center);// Surface normal
         distance = t.x;
      }
   }
   return distance < 1000.;
}

void main() {
   vec3 c = vec3(0.,0.,0.);

   V = vec3(0.,0.,0.);                         // Ray origin
   W = normalize(vec3(vPos.xy, -3.));          // Ray direction
   if (! raytrace())
      c = backgroundColor(vPos);
   else
      for (int bounce = 0 ; bounce < 5 ; bounce++) {
         float attenuation = pow(0.6, float(bounce + 1));
         c += attenuation * phong(P, N, E, C);
         c += .5 * attenuation * backgroundColor(W);
         V = P + .001 * W;
         W = reflect(W, N);
         if (! raytrace())
            break;
      }

   gl_FragColor = vec4(sqrt(c), 1.);           // Final pixel color
}
---------------------------------------------------------------------
Adding noise to the phong algorithm's result. Spheres appear to have
a weird, milky pattern. As a result of adding the noise to the phong
algorithm, it manifests essentially a reaction to the lights. I adapted
it from the soap function from the bubble breakdown.
---------------------------------------------------------------------
                                           x                x
---------------------------------------------------------------------
varying vec3 vPos;                         // Position in image
uniform float uTime;                       // Time

struct Light {                             // Light source data.
   vec3 direction;
   vec3 color;
};

struct Material {                          // Surface material data.
   vec3  ambient;
   vec3  diffuse;
   vec3  specular;
   float power;
};

struct Sphere {                            // Sphere object data.
   vec3     center;
   float    radius;
   Material material;
};

uniform Light uLights[NLIGHTS];            // All the lights.
uniform Sphere uSpheres[NSPHERES];         // All the spheres.

vec2 raytraceSphere(vec3 V, vec3 W, Sphere S) {
   V -= S.center;
   float B = 2. * dot(V, W);
   float C = dot(V, V) - S.radius * S.radius;
   float discrim = B*B - 4.*C;
   vec2 t = vec2(1000., 1000.);
   if (discrim > 0.)
      t = vec2(-B - discrim, -B + discrim) / 2.;
   return t.x > 0. ? t : vec2(1000., 1000.);
}

vec3 backgroundColor(vec3 dir) {
   float t = .5 - .5 * dir.y;
   return mix(vec3(.2,.01,.01), vec3(.01,.01,.1), 1. - t * t) *
               (turbulence(vec3(t, t, t)) * 5.);
}

vec3 phong(vec3 P, vec3 N, vec3 E, Material C) {
   vec3 c = C.ambient * backgroundColor(N);       // Ambient color
   c -= .05 * noise(4.2 * P);                     // Cloudiness
   for (int i = 0 ; i < NLIGHTS ; i++) { // Loop through lights
      vec3 L = normalize(uLights[i].direction);
      vec2 t;
      for (int j = 0 ; j < NSPHERES ; j++) {// Loop through spheres.
         t = raytraceSphere(P+.001*L, L, uSpheres[j]);
         if (t.x < 1000.)// If any casts a shadow then stop looping.
            break;
      }
      if (t.x == 1000.) {                      // If not in shadow:
         float d = max(0., dot(N, L));                // Diffuse
         vec3  R = reflect(-L, N);
         float s = pow(max(0., dot(E, R)), C.power);  // Specular
         c += uLights[i].color
              * (d * C.diffuse + s * C.specular * .1*C.power);
      }
   }
   return c;
}

Material C;
vec3 V, W, P, E, N;

bool raytrace() {
   float distance = 1000.;
   for (int i = 0 ; i < NSPHERES ; i++) {
      vec2 t = raytraceSphere(V, W, uSpheres[i]);
      if (t.x < distance) {                    // Properties for Obj
         C = uSpheres[i].material;             // Material
         P = V + t.x * W;                      // Point on sphere
         E = -normalize(P);                    // Direction to eye
         N = normalize(P - uSpheres[i].center);// Surface normal
         distance = t.x;
      }
   }
   return distance < 1000.;
}

void main() {
   vec3 c = vec3(0.,0.,0.);

   V = vec3(0.,0.,0.);                         // Ray origin
   W = normalize(vec3(vPos.xy, -3.));          // Ray direction
   if (! raytrace())
      c = backgroundColor(vPos);
   else
      for (int bounce = 0 ; bounce < 5 ; bounce++) {
         float attenuation = pow(0.6, float(bounce + 1));
         c += attenuation * phong(P, N, E, C);
         c += .5 * attenuation * backgroundColor(W);
         V = P + .001 * W;
         W = reflect(W, N);
         if (! raytrace())
            break;
      }

   gl_FragColor = vec4(sqrt(c), 1.);           // Final pixel color
}
---------------------------------------------------------------------
Reverted changes from the previous step.

"Subtracting" a very small amount of noise based on vPos before the
phong shading is done creates a smoky look. Because it's based on
vPos, it looks a lot like smoke rolling around inside the spheres, but
not quite. It might be because the spheres themselves don't look
like they're made out of glass.
---------------------------------------------------------------------
                                          x                x
---------------------------------------------------------------------
varying vec3 vPos;                         // Position in image
uniform float uTime;                       // Time

struct Light {                             // Light source data.
   vec3 direction;
   vec3 color;
};

struct Material {                          // Surface material data.
   vec3  ambient;
   vec3  diffuse;
   vec3  specular;
   float power;
};

struct Sphere {                            // Sphere object data.
   vec3     center;
   float    radius;
   Material material;
};

uniform Light uLights[NLIGHTS];            // All the lights.
uniform Sphere uSpheres[NSPHERES];         // All the spheres.

vec2 raytraceSphere(vec3 V, vec3 W, Sphere S) {
   V -= S.center;
   float B = 2. * dot(V, W);
   float C = dot(V, V) - S.radius * S.radius;
   float discrim = B*B - 4.*C;
   vec2 t = vec2(1000., 1000.);
   if (discrim > 0.)
      t = vec2(-B - discrim, -B + discrim) / 2.;
   return t.x > 0. ? t : vec2(1000., 1000.);
}

vec3 backgroundColor(vec3 dir) {
   float t = .5 - .5 * dir.y;
   return mix(vec3(.2,.01,.01), vec3(.01,.01,.1), 1. - t * t) *
               (turbulence(vec3(t, t, t)) * 5.);
}

vec3 phong(vec3 P, vec3 N, vec3 E, Material C) {
   vec3 c = C.ambient * backgroundColor(N);       // Ambient color
   c -= .05 * noise(4.2 * P);                     // Cloudiness
   c += .05 * turbulence(.1 * (uTime) + P);
   for (int i = 0 ; i < NLIGHTS ; i++) { // Loop through lights
      vec3 L = normalize(uLights[i].direction);
      vec2 t;
      for (int j = 0 ; j < NSPHERES ; j++) {// Loop through spheres.
         t = raytraceSphere(P+.001*L, L, uSpheres[j]);
         if (t.x < 1000.)// If any casts a shadow then stop looping.
            break;
      }
      if (t.x == 1000.) {                      // If not in shadow:
         float d = max(0., dot(N, L));                // Diffuse
         vec3  R = reflect(-L, N);
         float s = pow(max(0., dot(E, R)), C.power);  // Specular
         c += uLights[i].color
              * (d * C.diffuse + s * C.specular * .1*C.power);
      }
   }
   return c;
}

Material C;
vec3 V, W, P, E, N;

bool raytrace() {
   float distance = 1000.;
   for (int i = 0 ; i < NSPHERES ; i++) {
      vec2 t = raytraceSphere(V, W, uSpheres[i]);
      if (t.x < distance) {                    // Properties for Obj
         C = uSpheres[i].material;             // Material
         P = V + t.x * W;                      // Point on sphere
         E = -normalize(P);                    // Direction to eye
         N = normalize(P - uSpheres[i].center);// Surface normal
         distance = t.x;
      }
   }
   return distance < 1000.;
}

void main() {
   vec3 c = vec3(0.,0.,0.);

   V = vec3(0.,0.,0.);                         // Ray origin
   W = normalize(vec3(vPos.xy, -3.));          // Ray direction
   if (! raytrace())
      c = backgroundColor(vPos);
   else
      for (int bounce = 0 ; bounce < 5 ; bounce++) {
         float attenuation = pow(0.6, float(bounce + 1));
         c += attenuation * phong(P, N, E, C);
         c += .5 * attenuation * backgroundColor(W);
         V = P + .001 * W;
         W = reflect(W, N);
         if (! raytrace())
            break;
      }

   gl_FragColor = vec4(sqrt(c), 1.);           // Final pixel color
}
---------------------------------------------------------------------
The cloudy/smoky effect is greatly amplified by a bit of turbulence.
---------------------------------------------------------------------
                         x
---------------------------------------------------------------------
varying vec3 vPos;                         // Position in image
uniform float uTime;                       // Time

struct Light {                             // Light source data.
   vec3 direction;
   vec3 color;
};

struct Material {                          // Surface material data.
   vec3  ambient;
   vec3  diffuse;
   vec3  specular;
   float power;
};

struct Sphere {                            // Sphere object data.
   vec3     center;
   float    radius;
   Material material;
};

uniform Light uLights[NLIGHTS];            // All the lights.
uniform Sphere uSpheres[NSPHERES];         // All the spheres.

vec2 raytraceSphere(vec3 V, vec3 W, Sphere S) {
   S.center += noise(S.center);
   V -= S.center;
   float B = 2. * dot(V, W);
   float C = dot(V, V) - S.radius * S.radius;
   float discrim = B*B - 4.*C;
   vec2 t = vec2(1000., 1000.);
   if (discrim > 0.)
      t = vec2(-B - discrim, -B + discrim) / 2.;
   return t.x > 0. ? t : vec2(1000., 1000.);
}

vec3 backgroundColor(vec3 dir) {
   float t = .5 - .5 * dir.y;
   return mix(vec3(.2,.01,.01), vec3(.01,.01,.1), 1. - t * t);
}

vec3 phong(vec3 P, vec3 N, vec3 E, Material C) {
   vec3 c = C.ambient * backgroundColor(N);       // Ambient color
   for (int i = 0 ; i < NLIGHTS ; i++) { // Loop through lights
      vec3 L = normalize(uLights[i].direction);
      vec2 t;
      for (int j = 0 ; j < NSPHERES ; j++) {// Loop through spheres.
         t = raytraceSphere(P+.001*L, L, uSpheres[j]);
         if (t.x < 1000.)// If any casts a shadow then stop looping.
            break;
      }
      if (t.x == 1000.) {                      // If not in shadow:
         float d = max(0., dot(N, L));                // Diffuse
         vec3  R = reflect(-L, N);
         float s = pow(max(0., dot(E, R)), C.power);  // Specular
         c += uLights[i].color
              * (d * C.diffuse + s * C.specular * .1*C.power);
      }
   }
   return c;
}

Material C;
vec3 V, W, P, E, N;

bool raytrace() {
   float distance = 1000.;
   for (int i = 0 ; i < NSPHERES ; i++) {
      vec2 t = raytraceSphere(V, W, uSpheres[i]);
      if (t.x < distance) {                    // Properties for Obj
         C = uSpheres[i].material;             // Material
         P = V + t.x * W;                      // Point on sphere
         E = -normalize(P);                    // Direction to eye
         N = normalize(P - uSpheres[i].center);// Surface normal
         distance = t.x;
      }
   }
   return distance < 1000.;
}

void main() {
   vec3 c = vec3(0.,0.,0.);

   V = vec3(0.,0.,0.);                         // Ray origin
   W = normalize(vec3(vPos.xy, -3.));          // Ray direction
   if (! raytrace())
      c = backgroundColor(vPos);
   else
      for (int bounce = 0 ; bounce < 5 ; bounce++) {
         float attenuation = pow(0.6, float(bounce + 1));
         c += attenuation * phong(P, N, E, C);
         c += .5 * attenuation * backgroundColor(W);
         V = P + .001 * W;
         W = reflect(W, N);
         if (! raytrace())
            break;
      }

   gl_FragColor = vec4(sqrt(c), 1.);           // Final pixel color
}
---------------------------------------------------------------------
Warning: Framerates may suffer.
Removed cool background to save the frames.
Reverted changes from the previous two steps.

Adding noise to the center of the sphere can affect its position, as
the centers of our spheres are constantly in motion. It also causes
the sphere to interact with the lights in a very bizarre way. I'm
not really sure what's going on, frankly. It might be that the lights
are "inside" the spheres? Or that the spheres are reflecting on them-
selves? I don't know.
---------------------------------------------------------------------
                         xx
---------------------------------------------------------------------
varying vec3 vPos;                         // Position in image
uniform float uTime;                       // Time

struct Light {                             // Light source data.
   vec3 direction;
   vec3 color;
};

struct Material {                          // Surface material data.
   vec3  ambient;
   vec3  diffuse;
   vec3  specular;
   float power;
};

struct Sphere {                            // Sphere object data.
   vec3     center;
   float    radius;
   Material material;
};

uniform Light uLights[NLIGHTS];            // All the lights.
uniform Sphere uSpheres[NSPHERES];         // All the spheres.

vec2 raytraceSphere(vec3 V, vec3 W, Sphere S) {
   S.radius = (1.5 * sin(noise(S.center)) > S.radius)
               ? 1.5 * sin(noise(S.center)) : S.radius;
   V -= S.center;
   float B = 2. * dot(V, W);
   float C = dot(V, V) - S.radius * S.radius;
   float discrim = B*B - 4.*C;
   vec2 t = vec2(1000., 1000.);
   if (discrim > 0.)
      t = vec2(-B - discrim, -B + discrim) / 2.;
   return t.x > 0. ? t : vec2(1000., 1000.);
}

vec3 backgroundColor(vec3 dir) {
   float t = .5 - .5 * dir.y;
   return mix(vec3(.2,.01,.01), vec3(.01,.01,.1), 1. - t * t);
}

vec3 phong(vec3 P, vec3 N, vec3 E, Material C) {
   vec3 c = C.ambient * backgroundColor(N);       // Ambient color
   for (int i = 0 ; i < NLIGHTS ; i++) { // Loop through lights
      vec3 L = normalize(uLights[i].direction);
      vec2 t;
      for (int j = 0 ; j < NSPHERES ; j++) {// Loop through spheres.
         t = raytraceSphere(P+.001*L, L, uSpheres[j]);
         if (t.x < 1000.)// If any casts a shadow then stop looping.
            break;
      }
      if (t.x == 1000.) {                      // If not in shadow:
         float d = max(0., dot(N, L));                // Diffuse
         vec3  R = reflect(-L, N);
         float s = pow(max(0., dot(E, R)), C.power);  // Specular
         c += uLights[i].color
              * (d * C.diffuse + s * C.specular * .1*C.power);
      }
   }
   return c;
}

Material C;
vec3 V, W, P, E, N;

bool raytrace() {
   float distance = 1000.;
   for (int i = 0 ; i < NSPHERES ; i++) {
      vec2 t = raytraceSphere(V, W, uSpheres[i]);
      if (t.x < distance) {                    // Properties for Obj
         C = uSpheres[i].material;             // Material
         P = V + t.x * W;                      // Point on sphere
         E = -normalize(P);                    // Direction to eye
         N = normalize(P - uSpheres[i].center);// Surface normal
         distance = t.x;
      }
   }
   return distance < 1000.;
}

void main() {
   vec3 c = vec3(0.,0.,0.);

   V = vec3(0.,0.,0.);                         // Ray origin
   W = normalize(vec3(vPos.xy, -3.));          // Ray direction
   if (! raytrace())
      c = backgroundColor(vPos);
   else
      for (int bounce = 0 ; bounce < 5 ; bounce++) {
         float attenuation = pow(0.6, float(bounce + 1));
         c += attenuation * phong(P, N, E, C);
         c += .5 * attenuation * backgroundColor(W);
         V = P + .001 * W;
         W = reflect(W, N);
         if (! raytrace())
            break;
      }

   gl_FragColor = vec4(sqrt(c), 1.);           // Final pixel color
}
---------------------------------------------------------------------
Warning: Framerates may suffer.
Removed cool background to save the frames.
Reverted changes from the previous step.

We can also use the noise of a sphere's coordinates to affect its size!
---------------------------------------------------------------------
                                           x
---------------------------------------------------------------------
varying vec3 vPos;                         // Position in image
uniform float uTime;                       // Time

struct Light {                             // Light source data.
   vec3 direction;
   vec3 color;
};

struct Material {                          // Surface material data.
   vec3  ambient;
   vec3  diffuse;
   vec3  specular;
   float power;
};

struct Sphere {                            // Sphere object data.
   vec3     center;
   float    radius;
   Material material;
};

uniform Light uLights[NLIGHTS];            // All the lights.
uniform Sphere uSpheres[NSPHERES];         // All the spheres.

vec2 raytraceSphere(vec3 V, vec3 W, Sphere S) {
   V -= S.center;
   float B = 2. * dot(V, W);
   float C = dot(V, V) - S.radius * S.radius;
   float discrim = B*B - 4.*C;
   vec2 t = vec2(1000., 1000.);
   if (discrim > 0.)
      t = vec2(-B - discrim, -B + discrim) / 2.;
   return t.x > 0. ? t : vec2(1000., 1000.);
}

vec3 backgroundColor(vec3 dir) {
   float t = .5 - .5 * dir.y;
   return mix(vec3(.2,.01,.01), vec3(.01,.01,.1), 1. - t * t) *
               (turbulence(vec3(t, t, t)) * 5.);
}

vec3 phong(vec3 P, vec3 N, vec3 E, Material C) {
   vec3 c = C.ambient * backgroundColor(N);       // Ambient color
   c /= 2.5 * (noise(4. * P));
   for (int i = 0 ; i < NLIGHTS ; i++) { // Loop through lights
      vec3 L = normalize(uLights[i].direction);
      vec2 t;
      for (int j = 0 ; j < NSPHERES ; j++) {// Loop through spheres.
         t = raytraceSphere(P+.001*L, L, uSpheres[j]);
         if (t.x < 1000.)// If any casts a shadow then stop looping.
            break;
      }
      if (t.x == 1000.) {                      // If not in shadow:
         float d = max(0., dot(N, L));                // Diffuse
         vec3  R = reflect(-L, N);
         float s = pow(max(0., dot(E, R)), C.power);  // Specular
         c += uLights[i].color
              * (d * C.diffuse + s * C.specular * .1*C.power);
      }
   }
   return c;
}

Material C;
vec3 V, W, P, E, N;

bool raytrace() {
   float distance = 1000.;
   for (int i = 0 ; i < NSPHERES ; i++) {
      vec2 t = raytraceSphere(V, W, uSpheres[i]);
      if (t.x < distance) {                    // Properties for Obj
         C = uSpheres[i].material;             // Material
         P = V + t.x * W;                      // Point on sphere
         E = -normalize(P);                    // Direction to eye
         N = normalize(P - uSpheres[i].center);// Surface normal
         distance = t.x;
      }
   }
   return distance < 1000.;
}

void main() {
   vec3 c = vec3(0.,0.,0.);

   V = vec3(0.,0.,0.);                         // Ray origin
   W = normalize(vec3(vPos.xy, -3.));          // Ray direction
   if (! raytrace())
      c = backgroundColor(vPos);
   else
      for (int bounce = 0 ; bounce < 5 ; bounce++) {
         float attenuation = pow(0.6, float(bounce + 1));
         c += attenuation * phong(P, N, E, C);
         c += .5 * attenuation * backgroundColor(W);
         V = P + .001 * W;
         W = reflect(W, N);
         if (! raytrace())
            break;
      }

   gl_FragColor = vec4(sqrt(c), 1.);           // Final pixel color
}
---------------------------------------------------------------------
Reverted changes from the previous steps.

Dividing by noise produces some interesting results as well. First,
we can do it on the spheres, during phong shading. Divide the ambient
color by a noise function of the point on the sphere.

---------------------------------------------------------------------
                                           xx
---------------------------------------------------------------------
varying vec3 vPos;                         // Position in image
uniform float uTime;                       // Time

struct Light {                             // Light source data.
   vec3 direction;
   vec3 color;
};

struct Material {                          // Surface material data.
   vec3  ambient;
   vec3  diffuse;
   vec3  specular;
   float power;
};

struct Sphere {                            // Sphere object data.
   vec3     center;
   float    radius;
   Material material;
};

uniform Light uLights[NLIGHTS];            // All the lights.
uniform Sphere uSpheres[NSPHERES];         // All the spheres.

vec2 raytraceSphere(vec3 V, vec3 W, Sphere S) {
   V -= S.center;
   float B = 2. * dot(V, W);
   float C = dot(V, V) - S.radius * S.radius;
   float discrim = B*B - 4.*C;
   vec2 t = vec2(1000., 1000.);
   if (discrim > 0.)
      t = vec2(-B - discrim, -B + discrim) / 2.;
   return t.x > 0. ? t : vec2(1000., 1000.);
}

vec3 backgroundColor(vec3 dir) {
   float t = .5 - .5 * dir.y;
   return mix(vec3(.2,.01,.01), vec3(.01,.01,.1), 1. - t * t) *
               (turbulence(vec3(t, t, t)) * 5.);
}

vec3 phong(vec3 P, vec3 N, vec3 E, Material C) {
   vec3 c = C.ambient * backgroundColor(N);       // Ambient color
   c /= 2.5 * (noise(4. * P));
   c /= (noise(vPos));
   for (int i = 0 ; i < NLIGHTS ; i++) { // Loop through lights
      vec3 L = normalize(uLights[i].direction);
      vec2 t;
      for (int j = 0 ; j < NSPHERES ; j++) {// Loop through spheres.
         t = raytraceSphere(P+.001*L, L, uSpheres[j]);
         if (t.x < 1000.)// If any casts a shadow then stop looping.
            break;
      }
      if (t.x == 1000.) {                      // If not in shadow:
         float d = max(0., dot(N, L));                // Diffuse
         vec3  R = reflect(-L, N);
         float s = pow(max(0., dot(E, R)), C.power);  // Specular
         c += uLights[i].color
              * (d * C.diffuse + s * C.specular * .1*C.power);
      }
   }
   return c;
}

Material C;
vec3 V, W, P, E, N;

bool raytrace() {
   float distance = 1000.;
   for (int i = 0 ; i < NSPHERES ; i++) {
      vec2 t = raytraceSphere(V, W, uSpheres[i]);
      if (t.x < distance) {                    // Properties for Obj
         C = uSpheres[i].material;             // Material
         P = V + t.x * W;                      // Point on sphere
         E = -normalize(P);                    // Direction to eye
         N = normalize(P - uSpheres[i].center);// Surface normal
         distance = t.x;
      }
   }
   return distance < 1000.;
}

void main() {
   vec3 c = vec3(0.,0.,0.);

   V = vec3(0.,0.,0.);                         // Ray origin
   W = normalize(vec3(vPos.xy, -3.));          // Ray direction
   if (! raytrace())
      c = backgroundColor(vPos);
   else
      for (int bounce = 0 ; bounce < 5 ; bounce++) {
         float attenuation = pow(0.6, float(bounce + 1));
         c += attenuation * phong(P, N, E, C);
         c += .5 * attenuation * backgroundColor(W);
         V = P + .001 * W;
         W = reflect(W, N);
         if (! raytrace())
            break;
      }

   gl_FragColor = vec4(sqrt(c), 1.);           // Final pixel color
}
---------------------------------------------------------------------
You can further divide it based on a noise function of the vPos.
Notice the static line over the spheres where the vPos' noise
function's influence is most visible. Also notice how it interacts
with the noise already generated by the previous step's changes - the
"darker" and "lighter" areas invert on the right side of the line,
but remain the same on the left side of the line. However, both are
more intense.
---------------------------------------------------------------------
                                           xx                                                      x
---------------------------------------------------------------------
varying vec3 vPos;                         // Position in image
uniform float uTime;                       // Time

struct Light {                             // Light source data.
   vec3 direction;
   vec3 color;
};

struct Material {                          // Surface material data.
   vec3  ambient;
   vec3  diffuse;
   vec3  specular;
   float power;
};

struct Sphere {                            // Sphere object data.
   vec3     center;
   float    radius;
   Material material;
};

uniform Light uLights[NLIGHTS];            // All the lights.
uniform Sphere uSpheres[NSPHERES];         // All the spheres.

vec2 raytraceSphere(vec3 V, vec3 W, Sphere S) {
   V -= S.center;
   float B = 2. * dot(V, W);
   float C = dot(V, V) - S.radius * S.radius;
   float discrim = B*B - 4.*C;
   vec2 t = vec2(1000., 1000.);
   if (discrim > 0.)
      t = vec2(-B - discrim, -B + discrim) / 2.;
   return t.x > 0. ? t : vec2(1000., 1000.);
}

vec3 backgroundColor(vec3 dir) {
   float t = .5 - .5 * dir.y;
   return mix(vec3(.2,.01,.01), vec3(.01,.01,.1), 1. - t * t) *
               (turbulence(vec3(t, t, t)) * 5.);
}

vec3 phong(vec3 P, vec3 N, vec3 E, Material C) {
   vec3 c = C.ambient * backgroundColor(N);       // Ambient color
   c /= 2.5 * (noise(4. * P));
   c /= (noise(vPos));
   for (int i = 0 ; i < NLIGHTS ; i++) { // Loop through lights
      vec3 L = normalize(uLights[i].direction);
      vec2 t;
      for (int j = 0 ; j < NSPHERES ; j++) {// Loop through spheres.
         t = raytraceSphere(P+.001*L, L, uSpheres[j]);
         if (t.x < 1000.)// If any casts a shadow then stop looping.
            break;
      }
      if (t.x == 1000.) {                      // If not in shadow:
         float d = max(0., dot(N, L));                // Diffuse
         vec3  R = reflect(-L, N);
         float s = pow(max(0., dot(E, R)), C.power);  // Specular
         c += uLights[i].color
              * (d * C.diffuse + s * C.specular * .1*C.power);
      }
   }
   return c;
}

Material C;
vec3 V, W, P, E, N;

bool raytrace() {
   float distance = 1000.;
   for (int i = 0 ; i < NSPHERES ; i++) {
      vec2 t = raytraceSphere(V, W, uSpheres[i]);
      if (t.x < distance) {                    // Properties for Obj
         C = uSpheres[i].material;             // Material
         P = V + t.x * W;                      // Point on sphere
         E = -normalize(P);                    // Direction to eye
         N = normalize(P - uSpheres[i].center);// Surface normal
         distance = t.x;
      }
   }
   return distance < 1000.;
}

void main() {
   vec3 c = vec3(0.,0.,0.);

   V = vec3(0.,0.,0.);                         // Ray origin
   W = normalize(vec3(vPos.xy, -3.));          // Ray direction
   if (! raytrace())
      c = backgroundColor(vPos);
   else
      for (int bounce = 0 ; bounce < 5 ; bounce++) {
         float attenuation = pow(0.6, float(bounce + 1));
         c += attenuation * phong(P, N, E, C);
         c += .5 * attenuation * backgroundColor(W);
         V = P + .001 * W;
         W = reflect(W, N);
         if (! raytrace())
            break;
      }
   c += 10. * noise(vPos);
   gl_FragColor = vec4(sqrt(c), 1.);           // Final pixel color
}
---------------------------------------------------------------------
By adding the noise function on the vPos from everything right
before the fragments are colored in by the shader, we can see its
overall affect.
---------------------------------------------------------------------
                                           xx                                            x          x
---------------------------------------------------------------------
varying vec3 vPos;                         // Position in image
uniform float uTime;                       // Time

struct Light {                             // Light source data.
   vec3 direction;
   vec3 color;
};

struct Material {                          // Surface material data.
   vec3  ambient;
   vec3  diffuse;
   vec3  specular;
   float power;
};

struct Sphere {                            // Sphere object data.
   vec3     center;
   float    radius;
   Material material;
};

uniform Light uLights[NLIGHTS];            // All the lights.
uniform Sphere uSpheres[NSPHERES];         // All the spheres.

vec2 raytraceSphere(vec3 V, vec3 W, Sphere S) {
   V -= S.center;
   float B = 2. * dot(V, W);
   float C = dot(V, V) - S.radius * S.radius;
   float discrim = B*B - 4.*C;
   vec2 t = vec2(1000., 1000.);
   if (discrim > 0.)
      t = vec2(-B - discrim, -B + discrim) / 2.;
   return t.x > 0. ? t : vec2(1000., 1000.);
}

vec3 backgroundColor(vec3 dir) {
   float t = .5 - .5 * dir.y;
   return mix(vec3(.2,.01,.01), vec3(.01,.01,.1), 1. - t * t) *
               (turbulence(vec3(t, t, t)) * 5.);
}

vec3 phong(vec3 P, vec3 N, vec3 E, Material C) {
   vec3 c = C.ambient * backgroundColor(N);       // Ambient color
   c /= 2.5 * (noise(4. * P));
   c /= (noise(vPos));
   for (int i = 0 ; i < NLIGHTS ; i++) { // Loop through lights
      vec3 L = normalize(uLights[i].direction);
      vec2 t;
      for (int j = 0 ; j < NSPHERES ; j++) {// Loop through spheres.
         t = raytraceSphere(P+.001*L, L, uSpheres[j]);
         if (t.x < 1000.)// If any casts a shadow then stop looping.
            break;
      }
      if (t.x == 1000.) {                      // If not in shadow:
         float d = max(0., dot(N, L));                // Diffuse
         vec3  R = reflect(-L, N);
         float s = pow(max(0., dot(E, R)), C.power);  // Specular
         c += uLights[i].color
              * (d * C.diffuse + s * C.specular * .1*C.power);
      }
   }
   return c;
}

Material C;
vec3 V, W, P, E, N;

bool raytrace() {
   float distance = 1000.;
   for (int i = 0 ; i < NSPHERES ; i++) {
      vec2 t = raytraceSphere(V, W, uSpheres[i]);
      if (t.x < distance) {                    // Properties for Obj
         C = uSpheres[i].material;             // Material
         P = V + t.x * W;                      // Point on sphere
         E = -normalize(P);                    // Direction to eye
         N = normalize(P - uSpheres[i].center);// Surface normal
         distance = t.x;
      }
   }
   return distance < 1000.;
}

void main() {
   vec3 c = vec3(0.,0.,0.);

   V = vec3(0.,0.,0.);                         // Ray origin
   W = normalize(vec3(vPos.xy, -3.));          // Ray direction
   if (! raytrace()) {
      c = backgroundColor(vPos);
      c -= 0.5 * noise(vPos);
   } else
      for (int bounce = 0 ; bounce < 5 ; bounce++) {
         float attenuation = pow(0.6, float(bounce + 1));
         c += attenuation * phong(P, N, E, C);
         c += .5 * attenuation * backgroundColor(W);
         V = P + .001 * W;
         W = reflect(W, N);
         if (! raytrace())
            break;
      }

   gl_FragColor = vec4(sqrt(c), 1.);           // Final pixel color
}
---------------------------------------------------------------------
Reverted changes from the previous step.

Alternatively, we can only apply (a more subdued version of) the
vPos'noise function to the background where we're not drawing
anything on spheres, adding a bit more to our background, and
simulating an interaction between the background and the spheres.
</script>

<script>
addTextEditor(fss_script.innerHTML.split('---------------------------------------------------------------------'),
              function() { canvas1.setFragmentShader(this.value); });

function gl_uniform1f(gl, name, a)       { gl.uniform1f(gl.getUniformLocation(gl.program, name), a); }
function gl_uniform2f(gl, name, a,b)     { gl.uniform2f(gl.getUniformLocation(gl.program, name), a,b); }
function gl_uniform3f(gl, name, a,b,c)   { gl.uniform3f(gl.getUniformLocation(gl.program, name), a,b,c); }
function gl_uniform4f(gl, name, a,b,c,d) { gl.uniform4f(gl.getUniformLocation(gl.program, name), a,b,c,d); }

    const NLIGHTS = 10;
    const NSPHERES = 3;

    insertFragmentShaderCode(noise_shader);
    insertFragmentShaderCode('#define NLIGHTS ' + NLIGHTS + '\n');
    insertFragmentShaderCode('#define NSPHERES ' + NSPHERES + '\n');

    let uLights, uSpheres;

    gl_start(canvas1, vs_script.innerHTML,

        function (gl) {

            uLights = [];
            for (let i = 0; i < NLIGHTS; i++) {
                let name = 'uLights[' + i + '].';
                uLights.push({
                    direction: gl.getUniformLocation(gl.program, name + 'direction'),
                    color: gl.getUniformLocation(gl.program, name + 'color'),
                });
            }

            uSpheres = [];
            for (let i = 0; i < NSPHERES; i++) {
                let name = 'uSpheres[' + i + '].';
                uSpheres.push({
                    center: gl.getUniformLocation(gl.program, name + 'center'),
                    radius: gl.getUniformLocation(gl.program, name + 'radius'),
                    material: {
                        ambient: gl.getUniformLocation(gl.program, name + 'material.ambient'),
                        diffuse: gl.getUniformLocation(gl.program, name + 'material.diffuse'),
                        specular: gl.getUniformLocation(gl.program, name + 'material.specular'),
                        power: gl.getUniformLocation(gl.program, name + 'material.power'),
                    },
                });
            }

            function mix(a, b, t) { return a + t * (b - a); }

            for (let i = 0; i < uLights.length; i++) {
                const d = [];
                d[0] = Math.random() - .5;
                d[1] = Math.random() - .5;
                d[2] = Math.random() - .5;
                let t = .5 - .5 * d[1] / Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
                t = 1 - t * t;
                gl.uniform3f(uLights[i].direction, d[0], d[1], d[2]);
                gl.uniform3f(uLights[i].color, .5 * mix(1, .05, t)
                    , .5 * .05
                    , .5 * mix(.05, .5, t));
            }

            const a = [1, .8, 0];
            for (let i = 0; i < uSpheres.length; i++) {
                let j = (i + 1) % 3, k = (i + 2) % 3;
                gl.uniform1f(uSpheres[i].radius, .5);
                gl.uniform1f(uSpheres[i].material.power, 10);

                gl.uniform3f(uSpheres[i].material.ambient, a[i] * .1, a[j] * .1, a[k] * .1);
                gl.uniform3f(uSpheres[i].material.diffuse, a[i] * .1, a[j] * .1, a[k] * .1);
                gl.uniform3f(uSpheres[i].material.specular, a[i], a[j], a[k]);
            }
        },

        function (gl) {
            const d = 4;
            const s0 = .5 * Math.sin(.5 * time + .3);
            const c0 = .5 * Math.cos(.5 * time + .3);
            const s1 = .5 * Math.sin(.5 * time);
            const c1 = .5 * Math.cos(.5 * time);
            const s2 = .5 * Math.sin(.5 * time - .3);
            const c2 = .5 * Math.cos(.5 * time - .3);

            gl.uniform3f(uSpheres[0].center, c0, .45, -d + s0);
            gl.uniform3f(uSpheres[1].center, -.8 * c1, 0, -d - .8 * s1);
            gl.uniform3f(uSpheres[2].center, c2, -.45, -d + s2);
        }
    );
</script>
   
